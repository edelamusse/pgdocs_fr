<?xml version="1.0" encoding="UTF-8"?>
<!-- doc/src/sgml/ref/pgbench.sgml -->

<refentry id="pgbench">
 <indexterm zone="pgbench">
  <primary>pgbench</primary>
 </indexterm>

 <refmeta>
  <refentrytitle><application>pgbench</application></refentrytitle>
  <manvolnum>1</manvolnum>
  <refmiscinfo>Application</refmiscinfo>
 </refmeta>

 <refnamediv>
  <refname>pgbench</refname>
  <refpurpose>Réalise un test de benchmark pour
  <productname>PostgreSQL</productname></refpurpose>
 </refnamediv>

 <refsynopsisdiv>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg choice="plain"><option>-i</option></arg>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
  <cmdsynopsis>
   <command>pgbench</command>
   <arg rep="repeat"><replaceable>option</replaceable></arg>
   <arg choice="opt"><replaceable>nom_base</replaceable></arg>
  </cmdsynopsis>
 </refsynopsisdiv>

 <refsect1>
  <title>Description</title>
 <para>
  <application>pgbench</application> est un programme pour réaliser des
  tests de performances (<foreignphrase>benchmark</foreignphrase> en anglais)
  sur <productname>PostgreSQL</productname>.  Il
  exécute la même séquence de commandes SQL en continu, potentiellement
  avec plusieurs sessions concurrentes et ensuite il calcule le taux de
  transactions moyen (en transactions par secondes).
  Par défaut, <application>pgbench</application> teste un scénario
  vaguement basé sur TPC-B, impliquant cinq commandes <command>SELECT</command>,
  <command>UPDATE</command> et <command>INSERT</command> par
  transaction.
  Toutefois, il est facile de tester d'autres scénarios en écrivant
  ses propres scripts de transactions.
 </para>

 <para>
  Une sortie classique de <application>pgbench</application> ressemble
  à ceci&nbsp;:

<screen>
transaction type: TPC-B (sort of)
scaling factor: 10
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 85.184871 (including connections establishing)
tps = 85.296346 (excluding connections establishing)
</screen>

  Les six premières lignes rapportent quelques-uns des paramètres
  les plus importants qui ont été définis.
  La ligne suivante remonte le nombre de transactions réalisées et
  prévues. (La seconde rapporte juste le ratio entre le nombre de
  clients et le nombre de transactions par client).
  Ils seront équivalents à moins que l'exécution ait échoué avant la fin.
  (Avec le mode <option>-T</option>, seul le nombre réel de transactions
  est affiché.)
  Les deux dernières lignes remontent le nombre de transactions par
  secondes incluant ou pas le temps utilisé à démarrer une session.
 </para>

  <para>
   Les transactions tests, par défaut TPC-B, nécessitent d'avoir défini
   des tables spécfiques au préalable.
   <application>pgbench</application> devrait être utilisé avec l'option
   <option>-i</option> (initialisation) pour créer et peupler ces tables.
   (Si vous testez un script personnalisé, vous n'aurez pas besoin de
   cette étape, mais vous aurez besoin de mettre en place tout ce dont
   votre script aura besoin pour réaliser ces tests).
   Une initialisation ressemble à ça&nbsp;:

<programlisting>
pgbench -i <optional> <replaceable>autres-options</replaceable>
</optional> <replaceable>nom_base</replaceable>
</programlisting>

   Où <replaceable>nom_base</replaceable> est le nom de la base de données
   existante sur laquelle on conduit les tests. (Vous aurez aussi
   probablement besoin des options <option>-h</option>,
   <option>-p</option> et/ou <option>-U</option> qui spécifient comment
   se connecter à l'instance de base de données.)
  </para>

  <caution>
   <para>
    <literal>pgbench -i</literal> cré quatre tables nommées
    <structname>pgbench_accounts</structname>,
    <structname>pgbench_branches</structname>,
    <structname>pgbench_history</structname> et
    <structname>pgbench_tellers</structname>,
    détruisant toute table qui porterait l'un de ces noms.
    Attention à utiliser une autre base de données si vous avez
    des tables qui portent ces noms&nbsp;!
   </para>
  </caution>

  <para>
   Par défaut, avec un facteur d'échelle de 1, les tables contiennent
   intialement le nombre de lignes suivant&nbsp;:
<screen>
table                   # de lignes
---------------------------------
pgbench_branches        1
pgbench_tellers         10
pgbench_accounts        100000
pgbench_history         0
</screen>
   Vous pouvez (et, dans la plupart des cas, devriez) augmenter le nombre de
   lignes en utilisant l'option <option>-s</option>. Le facteur de remplissage
   <option>-F</option> peut aussi être utilisée à cet effet.
  </para>

  <para>
   Une fois les installations préliminaires réalisées, vous pouvez
   lancer vos benchmarks avec les options qui conviennent et ne plus
   utiliser l'option <option>-i</option>&nbsp;:

<programlisting>
pgbench <optional> <replaceable>options</replaceable> </optional>
<replaceable>nom_base</replaceable>
</programlisting>

   Dans presque tous les cas, vous allez avoir besoin de certaines
   options pour rendre vos tests plus pertinents.
   Les options les plus importantes sont celles qui concernent&nbsp;:
   le nombre de clients (<option>-c</option>),
   le nombre de transactions (<option>-t</option>),
   l'intervalle de temps (<option>-T</option>)  et
   le script à lancer (<option>-f</option>).
   Vous trouverez ci-dessous toutes les options disponibles.
  </para>
 </refsect1>

 <refsect1>
  <title>Options</title>

  <para>
   La partie suivante est divisée en trois sous-parties&nbsp;: Les
   options utiles à la phase d'initialisation sont différentes
   des options utilisées pendant les test de performances, et certaines
   options sont utiles dans les deux cas.
  </para>

 <refsect2 id="pgbench-init-options">
  <title>Options d'initialisation</title>

   <para>
    Pour réaliser l'initialisation, <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-i</option></term>
      <term><option>--initialize</option></term>
      <listitem>
       <para>
        Nécessaire pour être en mode initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-F</option>
      <replaceable>fillfactor</replaceable></term>
      <term><option>--fillfactor=
      </option><replaceable>fillfactor</replaceable></term>
      <listitem>
       <para>
        Crée les tables <structname>pgbench_accounts</structname>,
        <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname> avec le facteur de
        remplissage (fillfactor) spécifié.
        La valeur par défaut est 100.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
        Ne réalise pas d'opération de VACUUM après l'initialisation.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-q</option></term>
      <term><option>--quiet</option></term>
      <listitem>
       <para>
		Passe du mode verbeux au mode silencieux, en affichant seulement
		un message toutes les cinq secondes.
		Par défaut, on affiche un message toutes les 100000 lignes, ce
		qui engendre souvent la génération de plusieurs lignes de journal
		toutes les secondes (particulierement sur du bon matériel)
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option>
      <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option>
      <replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
        Multiplie le nombre de lignes générées par le facteur d'échelle (scale
        factor) Par exemple, <literal>-s 100</literal> va créer 10 millions de
        lignes dans la table <structname>pgbench_accounts</structname>. La
        valeur par défaut est 1. Lorsque l'échelle dépasse 20&nbsp;000, les
        colonnes utilisées pour contenir les identifiants de compte (colonnes
        <structfield>aid</structfield>) vont être converties en grands entiers
        (<type>bigint</type>), de manière à être suffisament grandes pour
        contenir un grand intervalle d'identifiants de compte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--foreign-keys</option></term>
      <listitem>
       <para>
        Crée une contrainte de type clé étrangère entre les tables standards.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--index-tablespace=<replaceable>index_tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée un index sur le tablespace spécifié, plutôt que sur le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--tablespace=<replaceable>tablespace</replaceable>
      </option></term>
      <listitem>
       <para>
        Crée une table sur le tablespace spécifié, plutôt que sur le
        tablespace par défaut.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--unlogged-tables</option></term>
      <listitem>
       <para>
        Crée toutes les tables en tant que tables non journalisées,
        plutôt qu'en tant que des tables permanentes.
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-run-options">
  <title>Options Benchmark</title>

   <para>
    Pour réaliser un benchmark <application>pgbench</application>
    accepte les arguments suivants en ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-c</option> <replaceable>clients</replaceable></term>
      <term><option>--client=
      </option><replaceable>clients</replaceable></term>
      <listitem>
       <para>
        Nombre de clients simulés, c'est-à-dire le nombre
        de sessions concurentes sur la base de données.
        La valeur par défaut est à 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-C</option></term>
      <term><option>--connect</option></term>
      <listitem>
       <para>
		Établit une nouvelle connexion pour chaque transaction, plutôt
		que de ne le faire qu'une seule fois par session cliente.
		C'est une option très utile pour mesurer la surcharge engendrée
		par la connexion.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-d</option></term>
      <term><option>--debug</option></term>
      <listitem>
       <para>
        Affiche les informations de debug.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-D</option> <replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <term><option>--define=</option><replaceable>variable</replaceable>
      <literal>=</literal><replaceable>value</replaceable></term>
      <listitem>
       <para>
        Définit une variable à utiliser pour un script personnalisé
        Voir ci-dessous pour plus de détails.
        Il est possible d'utiliser plusieurs fois l'option <option>-D</option>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-f</option> <replaceable>fichier</replaceable></term>
      <term><option>--file=</option>
      <replaceable>fichier</replaceable></term>
      <listitem>
       <para>
        Lit le script de transaction depuis le fichier
        <replaceable>filename</replaceable>.
        Voir ci-dessous pour plus de détails.
        Les options <option>-N</option>, <option>-S</option> et
        <option>-f</option> ne sont pas compatibles.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-j</option> <replaceable>threads</replaceable></term>
      <term><option>--jobs=</option>
      <replaceable>threads</replaceable></term>
      <listitem>
       <para>
        Nombre de processus utilisés dans
        <application>pgbench</application>.
        Utiliser plus d'un thread peut être utile sur des machines
        possédant plusieurs cœurs.
        Le nombre de clients doit être un multiple du nombre de threads,
        puisqu'on affecte le même nombre de sessions clientes à gérer à
        chaque thread.
        La valeur par défaut est 1.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-l</option></term>
      <term><option>--log</option></term>
      <listitem>
       <para>
        Rapporte le temps utilisé par chaque transaction dans le fichier
        journal.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-L</option> <replaceable>limite</replaceable></term>
      <term><option>--latency-limit=</option><replaceable>limite</replaceable></term>
      <listitem>
       <para>
        Chaque transaction dont la durée est supérieure à la limite
        définie par <replaceable>limite</replaceable> (en milliseconde)
        est comptabilisée et rapportée séparement en tant que
        <firstterm>late</firstterm>.
       </para>
       <para>
        Lorsqu'un bridage est spécifié(<option>--rate=... </option>),
        les transactions, qui ont en terme de
        planification un retard supérieur à
        <replaceable>limite</replaceable> (en milliseconde) et celles
        qui n'ont pas la possibilité de rattraper la limite de latence,
        ne sont simplement pas envoyées à l'instance.
        Elles sont comptabilisées et rapportées séparément en tant que
        <firstterm>skipped</firstterm> (ignorées).
       </para>
       </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-M</option>
      <replaceable>querymode</replaceable></term>
      <term><option>--protocol=</option>
      <replaceable>querymode</replaceable></term>
      <listitem>
       <para>
		Protocole à utiliser pour soumettre des requêtes au serveur:
          <itemizedlist>
           <listitem>
            <para><literal>simple</literal>&nbsp;: utilisation du protocole
            de requêtes standards.</para>
           </listitem>
           <listitem>
            <para><literal>extended</literal>&nbsp;: utilisation du protocole
            de requêtes étendues.</para>
           </listitem>
           <listitem>
            <para><literal>prepared</literal>&nbsp;: utilisation du protocole
            de requêtes étendues avec instructions préparées.</para>
           </listitem>
          </itemizedlist>
        Par défaut, le protocole de requêtes standards est utilisé
        (voir <xref linkend="protocol"/> pour plus d'informations).
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-n</option></term>
      <term><option>--no-vacuum</option></term>
      <listitem>
       <para>
		Ne réalise pas l'opération de maintenance VACUUM avant de lancer
		le test.
		Cette option est <emphasis>nécessaire</emphasis> si vous lancez
		un scénario de test personnalisé qui n'utilise pas les tables
		standards <structname>pgbench_accounts</structname>,
        <structname>pgbench_branches</structname>, <structname>
	    pgbench_history</structname> et <structname>pgbench_tellers
	    </structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-N</option></term>
      <term><option>--skip-some-updates</option></term>
      <listitem>
       <para>
        Ne met pas à jour <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname>.
        Cela permet d'éviter la contention engendrée par la mise à jour
        sur ces tables mais rendra les tests encore moins typés norme
        TPC-B.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-P</option> <replaceable>sec</replaceable></term>
      <term><option>--progress=</option>
      <replaceable>sec</replaceable></term>
      <listitem>
       <para>
        Affiche le rapport de progression toutes les <literal>sec
        </literal> secondes.
        Ce rapport inclut la durée du test, le nombre de
        transactions par seconde depuis le dernier rapport, et la
        latence moyenne sur les transactions ainsi que la déviation
        depuis le dernier rapport.
        Avec le bridage, la latence est calculée en fonction de la date
        de démarrage planifiée de la transaction
        (option <option>-R</option>). Elle y inclut aussi la latence
        moyenne du temps de planification.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-r</option></term>
      <term><option>--report-latencies</option></term>
      <listitem>
       <para>
        Rapporte la latence moyenne par instruction (temps d'exécution
        du point de vue du client) de chaque commande après la fin du
        benchmark.
        Voir ci-dessous pour plus de détails.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-R</option> <replaceable>rate</replaceable></term>
      <term><option>--rate=</option><replaceable>rate</replaceable></term>
      <listitem>
       <para>
		Plutôt que d'aller le plus vite possible, l'exécution des
		transactions vise à atteindre le ratio spécifié (fonctionnement
		par défaut). Le taux est donné en transactions par seconde.
		Si le ratio visé est supérieur au ratio maximum possible, la
		limite de ratio n'aura aucune influence sur le résultat.
       </para>
       <para>
		Ce ratio est visé en appliquant une loi de poisson sur le temps
		pour ordonnançer les transactions.
		La date de démarrage prévue est avancée au moment où le client a
		démarré sa transaction et pas sur le moment où la dernière
		transaction s'est arrêtée.
		Cette manière de procéder signifie que, si une transaction
		dépasse sa date de fin prévue, un rattrapage est encore possible
		pour les suivantes.
       </para>
       <para>
		Lorsque le bridage est actif, à la fin de l'exécution, on
		calcule, à partir de la date de démarrage, la latence de la
		transaction, c'est-à-dire que l'on calcule le temps d'attente
		pour chaque transaction que la précédente se soit terminée.
		Ce temps d'attente est appelé temps de latence d'ordonnancement,
		et ses valeurs moyenne et maximum sont rapportées séparément.
		Le temps de latence d'ordonnancement respecte la date réelle de
		démarrage. Par exemple, le temps d'exécution d'une transaction
		dans la base peut être récupéré en soustrayant le temps de
		latence d'ordonnancement à la latence précisée dans le rapport.
       </para>

       <para>
        Si l'option <option>--latency-limit</option> est utilisée avec
        l'option  <option>--rate</option>, une transaction peut avoir
        une telle latence qu'elle serait déja supérieure à limite de
        latence lorsque la transaction précédente se termine, car la
        latence est calculée au moment de la date de démarrage planifiée.
        Les transactions concernées ne sont pas envoyées à l'instance,
        elles sont complètement ignorées et comptabilisées séparément.
       </para>

       <para>
		Une latence de planification élevée est un indicateur sur le
		fait que le système ne peut pas traiter les transactions du
		ratio (nombre de processus - nombres de clients) spécifié.
		Lorsque le temps moyen d'exécution est plus important que
		l'intervalle planifié prévu entre chaque transaction, chaque
		transaction successive va prendre du retard, et la latence de
		planification va continuer de croître tout le long de la durée
		du test.
		Si cela se produit, vous devez réduire le taux de transaction
		que vous avez spécifié.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-s</option> <replaceable>scale_factor</replaceable></term>
      <term><option>--scale=</option><replaceable>scale_factor</replaceable></term>
      <listitem>
       <para>
		    Rapporte le facteur d'échelle dans la sortie de <application>pgbench</application>.
        Avec des tests encastrés, ce n'est pas nécessaire&nbsp;; le facteur
        d'échelle approprié sera détecté en comptant le nombre de lignes
        dans la table <structname>pgbench_branches</structname>.
        Toutefois, lors de l'utilisation d'un benchmark avec un scénario
        personnalisé (option <option>-f</option>), le facteur
        d'échelle sera ramené à 1 à moins que cette option ne soit utilisée.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-S</option></term>
      <term><option>--select-only</option></term>
      <listitem>
       <para>
		Réalise un scénario portant uniquement sur des ordres SELECT
		plutôt que typé TPC-B.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-t</option>
      <replaceable>transactions</replaceable></term>
      <term><option>--transactions=</option>
      <replaceable>transactions</replaceable></term>
      <listitem>
       <para>
		Nombre de transactions lancées par chaque client.
		La valeur par défaut est 10.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-T</option> <replaceable>seconds</replaceable></term>
      <term><option>--time=</option><replaceable>seconds</replaceable></term>
      <listitem>
       <para>
        Lance le test pour la durée spécifiée en secondes, plutôt que
        pour un nombre fixe de transactions par client.
        Les options <option>-t</option> et <option>-T</option> ne sont
        pas compatibles.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-v</option></term>
      <term><option>--vacuum-all</option></term>
      <listitem>
       <para>
        Réalise l'opération de VACUUM sur les quatre tables standards avant de
        lancer le test. Sans l'option <option>-n</option> ou
        <option>-v</option>, <application>pgbench</application> fera un VACUUM
        sur les tables <structname>pgbench_tellers</structname> et
        <structname>pgbench_branches</structname>, puis tronquera
        <structname>pgbench_history</structname>.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--aggregate-interval=
      <replaceable>secondes</replaceable></option></term>
      <listitem>
       <para>
        Taille de l'intervalle d'agrégation (en secondes). Cett option peut
        uniquement être utilisée avec <application>-l</application>.
        Avec cette option, le journal contiendra des résumés par
        intervalle (nombre de transactions, latence min/max, et deux champs
        additionnels utiles à l'estimation de la variance).
       </para>
       <para>
        Cette option n'est pour l'instant pas supportée sur les
        systèmes d'exploitation Windows.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>--sampling-rate=
      <replaceable>rate</replaceable></option></term>
      <listitem>
       <para>
        Le taux d'échantillonnage, est utilisé lors de l'écriture des
        données dans les journaux, afin de réduire la quantité de
        journaux générés.
		Si cette option est utilisée, il n'y a qu'une portion des
		transactions qui sont journalisées, suivant la proportion spécifiée.
		1.0 signifie que toutes les transactions sont journalisées,
		0.05 signifie que 5% de toutes les transactions sont
		journalisées.
       </para>
       <para>
		Pensez à prendre le taux d'échantillonnage en compte lorsque vous
		allez consulter le journal.
		Par exemple, lorsque vous évaluez les TPS, vous devrez multiplier
		les nombres en concordance. (Exemple, avec un taux
		d'échantillonage de 0.01, vous n'obtiendrez que 1/100 des TPS
		réelles).
       </para>
      </listitem>
     </varlistentry>

    </variablelist>
   </para>

 </refsect2>

 <refsect2 id="pgbench-common-options">
  <title>Options habituelles</title>

   <para>
    <application>pgbench</application> accepte les arguments suivants en
    ligne de commande&nbsp;:

    <variablelist>

     <varlistentry>
      <term><option>-h</option>
      <replaceable>hostname</replaceable></term>
      <term><option>--host=</option>
      <replaceable>hostname</replaceable></term>
      <listitem>
       <para>
        Le nom du serveur de base de données.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-p</option>
      <replaceable>port</replaceable></term>
      <term><option>--port=</option>
      <replaceable>port</replaceable></term>
      <listitem>
       <para>
        Le port d'écoute de l'instance sur le serveur de base de données.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-U</option>
      <replaceable>login</replaceable></term>
      <term><option>--username=</option>
      <replaceable>login</replaceable></term>
      <listitem>
       <para>
        Le nom de l'utilisateur avec lequel on se connecte à l'instance.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-V</option></term>
      <term><option>--version</option></term>
      <listitem>
       <para>
        Affiche la version de <application>pgbench</application>
        puis quitte.
       </para>
      </listitem>
     </varlistentry>

     <varlistentry>
      <term><option>-?</option></term>
      <term><option>--help</option></term>
      <listitem>
       <para>
         Affiche l'aide sur les arguments en ligne de commande de
		<application>pgbench</application> puis quitte.
       </para>
      </listitem>
     </varlistentry>
    </variablelist>
   </para>

 </refsect2>
 </refsect1>

 <refsect1>
  <title>Notes</title>

 <refsect2>
  <title>Quelles sont les <quote>transactions</quote> réellement exécutées
  dans <application>pgbench</application>&nbsp;?</title>

  <para>
   Le script de transactions par défaut exécute sept commandes par
   transaction&nbsp;:
  </para>

  <orderedlist>
   <listitem><para><literal>BEGIN;</literal></para></listitem>
   <listitem><para><literal>
   UPDATE pgbench_accounts SET abalance = abalance + :delta
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>SELECT abalance FROM pgbench_accounts
   WHERE aid = :aid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_tellers
   SET tbalance = tbalance + :delta
   WHERE tid = :tid;</literal></para></listitem>
   <listitem><para><literal>UPDATE pgbench_branches
   SET bbalance = bbalance + :delta
   WHERE bid = :bid;</literal></para></listitem>
   <listitem><para><literal>INSERT
   INTO pgbench_history (tid, bid, aid, delta, mtime)
   VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
   </literal></para></listitem>
   <listitem><para><literal>END;</literal></para></listitem>
  </orderedlist>

  <para>
   Si vous précisez l'option <option>-N</option>, les étapes 4 et 5 ne
   seront pas incluses dans la transaction. Si vous précisez l'option
   <option>-S</option>, seule la commande <command>SELECT</command> est
   lancée.
  </para>
 </refsect2>

 <refsect2>
  <title>Scripts personnalisés</title>

  <para>
   <application>pgbench</application> est capable d'utiliser des
   scénarios de test de performances personnalisés qui remplacent le
   script de transactions par défaut (décrit ci-dessus) par un script de
   transactions lu depuis le fichier spécifié avec l'option
   (<option>-f</option>).
   Dans ce cas, une <quote>transaction</quote> est comptabilisée comme
   une exécution d'un fichier script.
   Vous pouvez utiliser plusieurs fichiers (option <option>-f</option>
   répétable), auquel cas l'un des scripts est choisi de manière
   aléatoire à chaque fois qu'un client démarre une nouvelle
   transaction.
  </para>

  <para>
   Le format d'un fichier script est d'une seule commande par ligne&nbsp;;
   Les commandes SQL multi-lignes ne sont pas supportées.
   Les lignes vides ou les lignes débutant par <literal>--</literal>
   sont ignorés. Les lignes des fichiers de scripts peuvent aussi être
   des <quote>méta-commandes</quote>, qui seront interprétées par
   <application>pgbench</application> comme décrit dans la partie
   suivante.
  </para>

  <para>
   Il est possible simplement de substituer les variables dans les
   fichiers scripts.
   Les variables peuvent être instanciées via la ligne de commande avec
   l'option <option>-D</option> comme décrit ci-dessus ou grâce aux
   méta-commandes décrites ci-dessous.
   En plus des commandes pré-définies par l'option de la ligne de
   commande <option>-D</option>, il y a quelques variables qui sont
   automatiquement prédéfinies, listées sous
   <xref linkend="pgbench-automatic-variables"/>.
    Si une valeur pour l'une de ces variables a été définie via la
    ligne de commande avec l'option <option>-D</option>, elle sera prise
    en compte en priorité par rapport à la valeur définie
    automatiquement. Une fois définie, la valeur d'une variable peut
    être insérée dans les commandes SQL en écrivant <literal>:</literal>
    <replaceable>nom_variable</replaceable>.
    S'il y a plus d'une session par client, chaque session possède son
    propre jeu de variables.
  </para>

   <table id="pgbench-automatic-variables">
    <title>Variables automatiques</title>
    <tgroup cols="2">
     <thead>
      <row>
       <entry>Variable</entry>
       <entry>Description</entry>
      </row>
     </thead>

     <tbody>
      <row>
       <entry><literal>scale</literal></entry>
       <entry>facteur d'echelle courant</entry>
      </row>

      <row>
       <entry><literal>client_id</literal></entry>
       <entry>nombre unique permettant d'identifier la session client
       (commence à zero)</entry>
      </row>
     </tbody>
    </tgroup>
   </table>

  <para>
   Dans les fichiers de scripts, les méta-commandes commencent avec un
   anti-slash (<literal>\</literal>).
   Les arguments d'une méta-commande sont séparés par des espaces vides.
   Les méta-commmandes suivantes sont supportées&nbsp;:
  </para>

  <variablelist>
   <varlistentry>
    <term>
     <literal>\set <replaceable>nom_variable</replaceable>
     <replaceable>expression</replaceable></literal>
    </term>

    <listitem>
     <para>
	  Définit la variable <replaceable>nom_variable</replaceable> à une
	  valeur entière définie par <replaceable>expression</replaceable>.
      L'expression peut contenir un entier fixé comme
      <literal>5432</literal>, référencer des variables
      <literal>:</literal><replaceable>nom_variable</replaceable> et
      des expressions composées d'opérateurs unaires
      (<literal>-</literal>) ou binaires (<literal>+</literal>,
      <literal>-</literal>, <literal>*</literal>,
      <literal>/</literal>, <literal>%</literal>) avec leurs
       associativités habituelles et parenthèses.
     </para>

     <para>
      Exemples&nbsp;:
<programlisting>
\set ntellers 10 * :scale
\set aid (1021 * :aid) % (100000 * :scale) + 1
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setrandom <replaceable>nom_variable</replaceable>
     <replaceable>min</replaceable> <replaceable>max</replaceable>
     [ uniform | { gaussian | exponential } <replaceable>parametre</replaceable> ]</literal>
     </term>

    <listitem>
     <para>
  	  Définit la variable <replaceable>nom_variable</replaceable> à une
	    valeur entière et aléatoire incluse entre les limites
      <replaceable>min</replaceable> et <replaceable>max</replaceable>.
      Chaque limite peut être soit un entier constant soit une référence
      <literal>:</literal><replaceable>nom_variable</replaceable> à une
      variable ayant une valeur entière.
     </para>

     <para>
	  Par défaut, ou quand <literal>uniform</literal> est spécifié,
	  toutes les valeurs de l'intervalle sont utilisées avec la même
	  probabilité.
	  Spécifier l'option <literal>gaussian</literal> (gaussien)
	  ou <literal>exponential</literal> (exponentiel) modifie ce
	  comportement.
      Chacune de ces options nécessite un paramètre obligatoire qui
      détermine la forme précise de la distribution.
     </para>

     <para>
      Pour une distribution Gaussienne, l'intervalle est calqué sur la forme
      de la distribution de la loi normale (courbe classique de Gauss en forme
      de cloche) mais réduite à l'intervalle <literal>-parametre</literal>
      (limite gauche) et <literal>+parametre</literal> (limite droite). Les
      valeurs proches du centre de l'invervalle ont plus de chances d'être
      utilisées. Précisément, si <literal>PHI(x)</literal> est la fonction de
      répartition de la loi normale standard, et qu'on définit la moyenne
      <literal>mu</literal> de l'intervalle [min, max]&nbsp;:
      <literal>mu</literal> = <literal>(max + min) / 2.0</literal>, et on
      définit une nouvelle fonction de répartition f avec&nbsp;:
      <literallayout>
f(x) = PHI(2.0 * parametre * (x - mu) / (max - min + 1)) / (2.0 * PHI(parametre) - 1.0)
      </literallayout>
      Alors la valeur <replaceable>i</replaceable> comprise entre
      <replaceable>min</replaceable> et <replaceable>max</replaceable> inclus
      est tirée avec la probabilité suivante&nbsp;: <literal>f(i + 0.5) - f(i
      - 0.5)</literal>. Intuitivement, plus le paramètre
      <replaceable>parametre</replaceable> est grand, plus les valeurs proches
      du centre de l'intervalle vont être tirées souvent et moins les valeurs
      proches de <replaceable>min</replaceable> et
      <replaceable>max</replaceable> vont être tirées souvent. Environ 67% des
      valeurs tirées proviennent de l'intervalle centré sur la moyenne, et de
      <literal>1.0 / parametre</literal>, de large, c'est-à-dire un intervalle
      de <literal>0.5 / parametre</literal> de chaque côté de la moyenne. 95%
      des valeurs sont tirées de l'intervalle centré de <literal>2.0 /
      parametre</literal> de large, c'est-à-dire l'intervalle de <literal>1.0
      / parametre</literal> de chaque côté de la moyenne. Par exemple si
      <replaceable>parametre</replaceable> vaut 4, 67% des valeurs sont tirées
      du quart du milieu (1.0 / 4.0) de l'intervalle (de <literal>3.0 /
      8.0</literal> a <literal>5.0 / 8.0</literal>) et 95% de la moitié
      centrale (<literal>2.0 / 4.0</literal>) de l'intervalle, (second et
      troisième quartile). La plus petite valeur autorisée pour
      <replaceable>parametre</replaceable> est 2, pour des raisons de
      performance de la transformation de Box-Muller.
     </para>

     <para>
	  Pour une distribution exponentielle,
	  <replaceable>parametre</replaceable> contrôle la répartition en
	  tronquant la répartition à une distribution exponentielle très
	  décroissante, et ensuite en projetant les valeurs sur des entiers
	  entre les bornes.

	  Précisément, avec
	  <literallayout>
      f(x) = exp(-parametre * (x - min) / (max - min + 1)) / (1.0 - exp(-parametre))
      </literallayout>
	  Alors la valeur <replaceable>i</replaceable> comprise entre
	  <replaceable>min</replaceable> et <replaceable>max</replaceable>
	  inclus est tirée avec la probabilité suivante&nbsp;:
      <literal>f(x) - f(x + 1)</literal>.

	  Intuitivement, plus <replaceable>parametre</replaceable>, 
	  est grand, plus les valeurs proches de
	  <replaceable>min</replaceable> vont être tirées souvent et moins
	  les valeurs proches de <replaceable>max</replaceable> vont être
	  tirées souvent.

	  Plus le paramètre <replaceable>parametre</replaceable> est proche
	  de 0, plus la répartition sera uniforme.

      Une approximation grossière de la répartition est de dire que les
      1% de valeurs les plus fréquentes de l'intervalle, proche de 
      <replaceable>min</replaceable>, sont tirées à 
      <replaceable>parametre</replaceable>% du temps.
      La valeur <replaceable>parametre</replaceable> doit être
      strictement positive.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\setrandom aid 1 :naccounts gaussian 5.0
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\sleep
     <replaceable>number</replaceable> [ us | ms | s ]</literal>
    </term>

    <listitem>
     <para>
	  Entraîne la suspension de l'exécution du script pendant la durée
	  spécifiée en microsecondes (<literal>us</literal>), millisecondes
	  (<literal>ms</literal>) ou secondes (<literal>s</literal>).
	  Si l'unité n'est pas définie, l'unité par défaut est la seconde.
	  Il peut être soit un entier constant, soit une référence
	  <literal>:</literal><replaceable>nom_variable</replaceable> vers
	  une variable retournant un entier.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\sleep 10 ms
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\setshell <replaceable>nom_variable</replaceable>
     <replaceable>commande</replaceable> [
     <replaceable>argument</replaceable> ... ]</literal>
    </term>

    <listitem>
     <para>
      Définit la variable <replaceable>nom_variable</replaceable> comme
      le résultat d'une commande shell
      <replaceable>commande</replaceable>.
      La commande doit retourner un entier sur la sortie standard.
     </para>

     <para><replaceable>argument</replaceable> peut être soit une
     constante de type text soit une variable <literal>:</literal>
     <replaceable>nom_variable</replaceable> référençant une variable de
     n'importe quel type.
     Si vous voulez utiliser un <replaceable>argument</replaceable>
     qui commencerait par des symboles deux-points, vous devrez ajouter le symbole deux-point au début de
      <replaceable>argument</replaceable>.
     </para>

     <para>
      Example:
<programlisting>
\setshell variable_à_utiliser commande argument_litéral :variable
::literal_commencant_avec_deux_points
</programlisting></para>
    </listitem>
   </varlistentry>

   <varlistentry>
    <term>
     <literal>\shell <replaceable>commande
     </replaceable> [ <replaceable>argument</replaceable> ... ]
     </literal>
    </term>

    <listitem>
     <para>
      Identique à <literal>\setshell</literal>, mais le résultat sera
      ignoré.
     </para>

     <para>
      Exemple&nbsp;:
<programlisting>
\shell command literal_argument :variable ::literal_starting_with_colon
</programlisting></para>
    </listitem>
   </varlistentry>
  </variablelist>

  <para>
   En tant qu'exemple, la définition complète de la construction
   de la transaction style TPC-B est&nbsp;:

<programlisting>
\set nbranches :scale
\set ntellers 10 * :scale
\set naccounts 100000 * :scale
\setrandom aid 1 :naccounts
\setrandom bid 1 :nbranches
\setrandom tid 1 :ntellers
\setrandom delta -5000 5000
BEGIN;
UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
END;
</programlisting>
   Ce script autorise chaque itération de la transaction à référencer
   des lignes différentes, sélectionnées aléatoirement.
   (Cet exemple montre aussi pourquoi il est important que chaque session
   cliente ait ses propres variables &mdash; sinon elles n'affecteront
   pas les différentes lignes de façon indépendantes.
  </para>

 </refsect2>

 <refsect2>
  <title>Connexion par transaction</title>

  <para>
   Avec l'option <option>-l</option> mais sans l'option
   <option>--aggregate-interval</option>,
   <application>pgbench</application> va écrire le temps utilisé par
   chaque transaction dans un fichier journal.
   Ce fichier journal s'appellera
   <filename>pgbench_log.<replaceable>nnn</replaceable></filename> où
   <replaceable>nnn</replaceable> est le PID du processus
   <application>pgbench</application>.
   Si l'option <option>-j</option> est positionnée à 2 ou plus,
   créant plusieurs processus de travail (<foreignphrase>worker</foreignphrase>),
   chacun aura son propre fichier journal.
   Le premier worker utilisera le même nom pour son fichier journal
   que dans le cas d'un seul processus.
   Les fichiers journaux supplémentaires s'appelleront
   <filename>pgbench_log.<replaceable>nnn</replaceable>.<replaceable>mmm</replaceable></filename>,
   où <replaceable>mmm</replaceable> est un numéro de séquence,
   identifiant chaque worker supplémentaire, en commençant à 1.
  </para>

  <para>
   Le format du journal est le suivant&nbsp;:

<synopsis>
<replaceable>id_client</replaceable>
<replaceable>no_transaction</replaceable>
<replaceable>temps</replaceable> <replaceable>no_fichier</replaceable>
<replaceable>time_epoch</replaceable> <replaceable>time_us</replaceable>
<optional><replaceable>schedule_lag</replaceable></optional>
</synopsis>

   Où <replaceable>temps</replaceable> est la durée totale de la
   transaction en micro secondes, <replaceable>no_fichier</replaceable>
   identifie quel fichier script est utilisé (très utile lorsqu'on
   utilise plusieurs scripts avec l'option <option>-f</option>), et
   <replaceable>time_epoch</replaceable>/<replaceable>time_us</replaceable>
   et un horodatage unix avec un décalage en micro secondes (utilisable pour
   créer un horodatage ISO 8601 avec des secondes fractionnées) qui montre
   à quel moment la transaction s'est terminée.

   Le champ <replaceable>schedule_lag</replaceable> est la différence
   entre la date de début planifiée de la transaction et la date de
   début effective de la transaction, en micro secondes.
   Il est présent uniquement lorsque l'option <option>--rate</option> est
   utilisée.

   Le dernier champ <replaceable>skipped_transactions</replaceable>
   rapporte le nombre de transactions ignorées car elles avaient trop de
   retard par rapport à la planification.
   Il est uniquement présent lorsque les deux options
   <option>--rate</option> et <option>--latency-limit</option>
   sont utilisées.
  </para>

  <para>
   Ci-dessous un extrait du fichier journal généré&nbsp;:
<screen>
 0 199 2241 0 1175850568 995598
 0 200 2465 0 1175850568 998079
 0 201 2513 0 1175850569 608
 0 202 2038 0 1175850569 2663
</screen>

   Un autre exemple avec les options <literal>--rate=100</literal> et
   <literal>--latency-limit=5</literal> (vous noterez
   la colonne supplémentaire <replaceable>schedule_lag</replaceable> )&nbsp;:
<screen>
 0 81 4621 0 1412881037 912698 3005
 0 82 6173 0 1412881037 914578 4304
 0 83 skipped 0 1412881037 914578 5217
 0 83 skipped 0 1412881037 914578 5099
 0 83 4722 0 1412881037 916203 3108
 0 84 4142 0 1412881037 918023 2333
 0 85 2465 0 1412881037 919759 740
</screen>
   Dans cet exemple, la transaction 82 est en retard, elle affiche une
   latence (6,173 ms) supérieure à la limite de 5 ms.
   Les deux transactions suivantes ont été ignorées car elles avaient
   déjà du retard avant même le début de la transaction.
  </para>

  <para>
   Dans le cas où on lance un test long, sur du matériel qui peut
   supporter un grand nombre de transactions, le fichier journal
   peut devenir très volumineux.
   L'option <option>--sampling-rate</option> peut être utilisée pour
   journaliser seulement un extrait aléatoire des transactions
   effectuées.
  </para>
 </refsect2>

 <refsect2>
  <title>Agrégation de la journalisation</title>

  <para>
   Avec l'option <option>--aggregate-interval</option>, les fichiers
   journaux utilisent un format quelque peu différent&nbsp;:

<synopsis>
<replaceable>début_intervalle</replaceable>
<replaceable>nombre_de_transations</replaceable>
<replaceable>somme_latence</replaceable>
<replaceable>somme latence_2</replaceable>
<replaceable>latence_minimum</replaceable>
<replaceable>latence_maximum</replaceable>
<optional><replaceable>somme_retard</replaceable>
<replaceable>somme_retard_2</replaceable>
<replaceable>retard_min</replaceable>
<replaceable>retard_max</replaceable>
<optional><replaceable>transactions_ignorées</replaceable>
</optional></optional>
</synopsis>

   Où <replaceable>début_intervalle</replaceable> est le début de
   l'intervalle (au format horodatage unix),
   <replaceable>nombre_de_transations</replaceable>  est le nombre de
   transactions dans l'intervalle,
   <replaceable>somme_latence</replaceable> est le cumul des latences
   (ce qui vous permet de déduire facilement la latence moyenne).
   Les deux champs suivants sont très utiles pour calculer la variance.
   En effet, <replaceable>somme_latence</replaceable> est la somme des
   latences, alors que <replaceable>somme_latence_2</replaceable> est la
   somme des latences au carré. Les deux derniers champs sont
   <replaceable>latence_min</replaceable>, la latence minimum dans
   l'intervalle, et <replaceable>latence_max</replaceable>, la latence
   maximum dans l'intervalle. Une transaction est comptée dans un
   intervalle à partir du moment où elle a été validée.
   Les derniers champs <replaceable>somme_retard</replaceable>,
   <replaceable>somme_retard_2</replaceable>,
   <replaceable>retard_min</replaceable>,
   et <replaceable>retard_max</replaceable> sont présents uniquement si
   l'option <option>--rate</option> a été spécifiée.
   Le tout dernier champ,
   <replaceable>transactions_ignorées</replaceable>, est présent
   uniquement si l'option <option>--latency-limit</option> a aussi été
   utilisée.
   Ils sont calculés sur le delta entre le moment où la transaction a
   pu commencer par rapport au moment la dernière s'est terminée,
   précisément la différence pour chaque transaction entre le moment où
   il était prévu qu'elle commence et le moment où elle a effectivement
   pu commencer.
  </para>

  <para>
   Voici un exemple de sortie&nbsp;:
<screen>
1345828501 5601 1542744 483552416 61 2573
1345828503 7884 1979812 565806736 60 1479
1345828505 7208 1979422 567277552 59 1391
1345828507 7685 1980268 569784714 60 1398
1345828509 7073 1979779 573489941 236 1411
</screen></para>

  <para>
   Notez que, tant que le fichier journal est brut (c'est-à-dire non
   agrégé), il contient des index des fichiers scripts personnalisés
   que le fichier journal agrégé ne contient pas. De ce fait, si vous
   avez besoin des données de vos scripts, vous devrez agréger ces
   données vous-même.
  </para>

 </refsect2>

 <refsect2>
  <title>Latences par requête</title>

  <para>
   Avec l'option <option>-r</option>, <application>pgbench</application>
   collecte le temps de transaction écoulé pour chaque requête,
   exécutée par chaque client.
   Une fois que le test de performance est terminé, il rapporte une
   moyenne de ces valeurs, référencée comme la latence de chaque requête.
  </para>

  <para>
   Pour le script par défaut, le résultat aura la forme suivante&nbsp;:
<screen>
starting vacuum...end.
transaction type: TPC-B (sort of)
scaling factor: 1
query mode: simple
number of clients: 10
number of threads: 1
number of transactions per client: 1000
number of transactions actually processed: 10000/10000
tps = 618.764555 (including connections establishing)
tps = 622.977698 (excluding connections establishing)
statement latencies in milliseconds:
        0.004386        \set nbranches 1 * :scale
        0.001343        \set ntellers 10 * :scale
        0.001212        \set naccounts 100000 * :scale
        0.001310        \setrandom aid 1 :naccounts
        0.001073        \setrandom bid 1 :nbranches
        0.001005        \setrandom tid 1 :ntellers
        0.001078        \setrandom delta -5000 5000
        0.326152        BEGIN;
        0.603376        UPDATE pgbench_accounts SET abalance = abalance + :delta WHERE aid = :aid;
        0.454643        SELECT abalance FROM pgbench_accounts WHERE aid = :aid;
        5.528491        UPDATE pgbench_tellers SET tbalance = tbalance + :delta WHERE tid = :tid;
        7.335435        UPDATE pgbench_branches SET bbalance = bbalance + :delta WHERE bid = :bid;
        0.371851        INSERT INTO pgbench_history (tid, bid, aid, delta, mtime) VALUES (:tid, :bid, :aid, :delta, CURRENT_TIMESTAMP);
        1.212976        END;
</screen>
  </para>

  <para>
   Les moyennes seront rapportées séparément si plusieurs scripts ont
   été spécifiés.
  </para>

  <para>
   Notez que la collecte supplémentaire des informations de
   chronométrage nécessaires pour la récupération de la latence par
   transaction induit une certaine surcharge.
   En effet, cela va réduire la vitesse moyenne calculée pour l'exécution
   des transactions et réduire le taux calculé des TPS.
   Le ralentissement varie de manière significative selon la
   plateforme et le matériel qui est utilisé pour le test.
   Comparer la moyenne des valeurs de TPS avec et sans l'intégration
   de la latence dans le test est une bonne manière de se rendre compte
   si la surcharge induite par le chronométrage est importante ou pas.
  </para>
 </refsect2>

 <refsect2>
  <title>Bonnes pratiques</title>

  <para>
   Il facile de se retrouver à utiliser
   <application>pgbench</application> et ne produire finalement que
   des résultats complètement insignifiants&nbsp;!
   Voici quelques conseils pour vous aider à récupérer des résultats
   pertinents.
  </para>

  <para>
   Tout d'abord, ne pensez <emphasis>jamais</emphasis> qu'un test ne
   peut durer que quelques secondes.
   Utilisez l'option <option>-t</option> ou <option>-T</option>
   pour vous assurer que le test dure au moins quelques minutes, de
   façon à lisser le bruit.
   Dans certains cas, il vous faudra des heures pour récupérer des
   valeurs reproductibles.
   Une bonne idée, lancez plusieurs fois votre test, de manière à vous
   rendre compte si les chiffres que vous obtenez sont ou pas
   reproductibles.
  </para>

  <para>
   Pour le scénario de test par défaut typé TPC-B, l'initialisation
   du facteur d'échelle (<option>-s</option>) devrait être au moins
   aussi grand que le nombre maximum de clients que vous avez
   l'intention de tester (<option>-c</option>)&nbsp;; sinon vous allez
   principalement tester la contention induite par les mises à jour.
   il n'y a que <option>-s</option> lignes dans la table
   <structname>pgbench_branches</structname>, et chaque transaction
   veut mettre à jour l'une de ces lignes, donc si la valeur de
   <option>-c</option> est supérieure à la valeur de <option>-s</option>,
   indubitablement, il en résultera de nombreuses transactions bloquées
   en attente de la fin d'autres transactions.
  </para>

  <para>
   Le moment où les tables ont été créées va sensiblement influencer le
   résultat du scénario de test par défaut, compte tenu de l'accumulation
   des lignes et espaces morts dans les tables lors du test.
   Pour comprendre les résultats, vous devriez garder une trace du
   nombre total de mises à jour ainsi que le moment où l'opération
   de VACUUM a lieu. Si la tâche autovacuum est active, il peut en
   résulter des variations imprévisibles dans les performances mesurées.
  </para>

  <para>
   Une limitation de <application>pgbench</application> est qu'il peut
   lui-même devenir le goulet d'étranglement lorsqu'il essaye de tester
   un grand nombre de sessions clientes.
   Cela peut être attenué en utilisant <application>pgbench</application>
   depuis une machine différente de la machine où se trouve la base
   de données, bien qu'une faible latence sur le réseau soit dans ce cas
   essentielle.
   Il peut même être utile de lancer plusieurs fois
   <application>pgbench</application> de manière concurrente, depuis
   plusieurs machines clientes vers le même serveur de base de données.
  </para>
 </refsect2>
 </refsect1>
</refentry>
